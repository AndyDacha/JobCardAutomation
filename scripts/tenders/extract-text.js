import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { execFileSync } from 'child_process';
import * as pdfjsLib from 'pdfjs-dist/legacy/build/pdf.mjs';
import mammoth from 'mammoth';
import os from 'os';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function walk(dir) {
  const out = [];
  for (const ent of fs.readdirSync(dir, { withFileTypes: true })) {
    const p = path.join(dir, ent.name);
    if (ent.isDirectory()) out.push(...walk(p));
    else out.push(p);
  }
  return out;
}

async function extractPdfText(filePath) {
  const data = new Uint8Array(fs.readFileSync(filePath));
  const doc = await pdfjsLib.getDocument({ data }).promise;
  let text = '';
  for (let i = 1; i <= doc.numPages; i++) {
    const page = await doc.getPage(i);
    const content = await page.getTextContent();
    const pageText = (content.items || [])
      .map((it) => (it && typeof it.str === 'string' ? it.str : ''))
      .join(' ')
      .replace(/\s+/g, ' ')
      .trim();
    if (pageText) text += (text ? '\n\n' : '') + pageText;
  }
  return text.trim();
}

async function extractDocxText(filePath) {
  const res = await mammoth.extractRawText({ path: filePath });
  const raw = String(res.value || '').replace(/\r\n/g, '\n').trim();
  if (raw) return raw;

  // Some DOCX files (often generated by export tools) store their real content in altChunk
  // as embedded zip parts (e.g. word/docx1.zip) which may contain HTML (word/html1.htm).
  // Mammoth doesn't resolve altChunk; we do a best-effort extraction here.
  try {
    const list = execFileSync('/usr/bin/unzip', ['-Z1', filePath], { encoding: 'utf8' });
    const entries = String(list || '')
      .split('\n')
      .map((x) => x.trim())
      .filter(Boolean);

    const altZips = entries.filter((e) => /^word\/docx\d+\.zip$/i.test(e));
    if (!altZips.length) return '';

    const htmlToText = (html) => {
      let s = String(html || '');
      // drop scripts/styles
      s = s.replace(/<script[\s\S]*?<\/script>/gi, '');
      s = s.replace(/<style[\s\S]*?<\/style>/gi, '');
      // convert common breaks to newlines
      s = s.replace(/<(br|\/p|\/tr|\/div|\/h[1-6])\b[^>]*>/gi, '\n');
      s = s.replace(/<li\b[^>]*>/gi, '- ');
      s = s.replace(/<\/li>/gi, '\n');
      // strip remaining tags
      s = s.replace(/<[^>]+>/g, ' ');
      // basic entity decoding
      s = s
        .replace(/&nbsp;/gi, ' ')
        .replace(/&amp;/gi, '&')
        .replace(/&lt;/gi, '<')
        .replace(/&gt;/gi, '>')
        .replace(/&quot;/gi, '"')
        .replace(/&#39;/g, "'");
      // collapse whitespace
      s = s.replace(/\r\n/g, '\n');
      s = s.replace(/[ \t]+\n/g, '\n');
      s = s.replace(/\n{3,}/g, '\n\n');
      s = s.replace(/[ \t]{2,}/g, ' ');
      return s.trim();
    };

    const chunks = [];
    for (const z of altZips) {
      const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'docx-altchunk-'));
      const zipPath = path.join(tmpDir, path.basename(z));
      fs.writeFileSync(zipPath, execFileSync('/usr/bin/unzip', ['-p', filePath, z]));

      const subList = execFileSync('/usr/bin/unzip', ['-Z1', zipPath], { encoding: 'utf8' });
      const subEntries = String(subList || '')
        .split('\n')
        .map((x) => x.trim())
        .filter(Boolean);

      const htmlEntry = subEntries.find((e) => /^word\/html\d+\.htm(l)?$/i.test(e));
      if (!htmlEntry) continue;

      const html = execFileSync('/usr/bin/unzip', ['-p', zipPath, htmlEntry], { encoding: 'utf8' });
      const txt = htmlToText(html);
      if (txt) chunks.push(txt);
    }

    return chunks.join('\n\n').trim();
  } catch {
    return '';
  }
}

function extractDocText(filePath) {
  // macOS: use textutil for .doc
  const out = execFileSync('/usr/bin/textutil', ['-convert', 'txt', '-stdout', filePath], { encoding: 'utf8' });
  return String(out || '').trim();
}

async function extractFileText(filePath) {
  const ext = path.extname(filePath).toLowerCase();
  if (ext === '.pdf') return await extractPdfText(filePath);
  if (ext === '.docx') return await extractDocxText(filePath);
  if (ext === '.doc') return extractDocText(filePath);
  return '';
}

async function main() {
  const target = process.argv[2] || path.join(__dirname, '../../Tender Learning/East Riding of Yorkshire');
  const outDir = process.argv[3] || path.join(__dirname, '../../tender-extract');
  fs.mkdirSync(outDir, { recursive: true });

  const files = fs.existsSync(target) && fs.statSync(target).isDirectory() ? walk(target) : [target];
  const candidates = files.filter((f) => /\.(pdf|docx|doc)$/i.test(f));

  const indexPath = path.join(outDir, '_index.json');
  const existingIndexArr = fs.existsSync(indexPath)
    ? (() => {
        try {
          const raw = fs.readFileSync(indexPath, 'utf8');
          const parsed = JSON.parse(raw);
          return Array.isArray(parsed) ? parsed : [];
        } catch {
          return [];
        }
      })()
    : [];

  const existingByFile = new Map(existingIndexArr.map((x) => [String(x?.file || ''), x]));
  const index = [...existingIndexArr];

  for (const f of candidates) {
    const rel = path.relative(path.join(__dirname, '../..'), f);
    try {
      const text = await extractFileText(f);
      const safeName = rel.replace(/[\\/]/g, '__').replace(/[^a-zA-Z0-9._-]/g, '_');
      const outPath = path.join(outDir, safeName + '.txt');
      fs.writeFileSync(outPath, text, 'utf8');
      const entry = { file: rel, out: path.relative(path.join(__dirname, '../..'), outPath), chars: text.length };
      if (existingByFile.has(rel)) {
        const idx = index.findIndex((x) => String(x?.file || '') === rel);
        if (idx >= 0) index.splice(idx, 1);
      }
      index.push(entry);
      // eslint-disable-next-line no-console
      console.log(`OK ${rel} -> ${outPath} (${text.length} chars)`);
    } catch (e) {
      const entry = { file: rel, out: null, chars: 0, error: e?.message || String(e) };
      if (existingByFile.has(rel)) {
        const idx = index.findIndex((x) => String(x?.file || '') === rel);
        if (idx >= 0) index.splice(idx, 1);
      }
      index.push(entry);
      // eslint-disable-next-line no-console
      console.log(`ERR ${rel}: ${e?.message || e}`);
    }
  }

  index.sort((a, b) => String(a?.file || '').localeCompare(String(b?.file || '')));
  fs.writeFileSync(indexPath, JSON.stringify(index, null, 2), 'utf8');
}

main().catch((e) => {
  // eslint-disable-next-line no-console
  console.error(e);
  process.exit(1);
});

